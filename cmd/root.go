package cmd

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"

	"github.com/cristianoliveira/sway-setter/internal/parser"
	"github.com/cristianoliveira/sway-setter/internal/sway"
	"github.com/jessevdk/go-flags"
)

type CliArgs struct {
	Type  string `short:"t" long:"type" description:"Type 'set_{type}' object to be set analog of 'swaymsg -t get_{type}'"`
	Print bool   `short:"p" long:"print" description:"Prints commands that would be executed. Can be used as input to swaymsg"`
}

func Args() *CliArgs {
	var opts CliArgs

	if len(os.Args) <= 1 {
		flags.ParseArgs(&opts, []string{"-h"})
		os.Exit(1)
	}

	args := os.Args[1:]
	args, err := flags.ParseArgs(&opts, args)
	if err != nil {
		os.Exit(0)
	}

	return &opts
}

func ScanStdin() (string, error) {
	input := ""
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		input += scanner.Text() + "\n"
	}

	if scanner.Err() != nil {
		err := scanner.Err()
		return "", fmt.Errorf("Error: failed to read input\n%s", err)
	}

	if len(input) == 0 {
		return "", fmt.Errorf("Error: no input provided")
	}

	return input, nil
}

var SetOptions = []string{"set_workspaces", "set_outputs"}

func Execute(opts *CliArgs) error {
	var err error
	scanner := bufio.NewScanner(os.Stdin)
	if scanner.Err() != nil {
		err = scanner.Err()
		return fmt.Errorf("Error: failed to read input\n%s", err)
	}

	if opts.Print {
		sway.ConfigStdoutConnector()
	}

	swaymsg, err := sway.ConnectToSway()
	if err != nil {
		return err
	}

	switch opts.Type {
	case "set_workspaces":
		input, err := ScanStdin()
		if err != nil {
			return err
		}

		var workspaces []parser.SwayWorkspace
		err = json.Unmarshal([]byte(input), &workspaces)
		if err != nil {
			return fmt.Errorf("Error: failed to parse input content\nHint: make sure to use a file generated by the `swaymsg -t get_workspaces` output")
		}

		commands, err := parser.SetWorkspacesCommand(workspaces)
		if err != nil {
			return err
		}

		err = swaymsg.Commands(commands)
		if err != nil {
			return err
		}

		return nil

	case "set_outputs":
		input, err := ScanStdin()
		if err != nil {
			return err
		}

		var outputs []parser.SwayOutput
		err = json.Unmarshal([]byte(input), &outputs)
		if err != nil {
			return fmt.Errorf("Error: failed to parse input content\nHint: make sure to use a file generated by the `swaymsg -t get_outputs` output")
		}

		commands, err := parser.SetOutputsCommand(outputs)
		if err != nil {
			return err
		}

		err = swaymsg.Commands(commands)
		if err != nil {
			return err
		}

		return nil

	case "set_containers":
		input, err := ScanStdin()
		if err != nil {
			return err
		}

		var tree parser.SwayRoot
		err = json.Unmarshal([]byte(input), &tree)
		if err != nil {
			return fmt.Errorf("Error: no outputs found in the tree json.\nHint: make sure to use a file generated by the `swaymsg -t get_tree` output")
		}

		workspaces, err := parser.CollectWorkspaces(tree)
		if err != nil {
			return fmt.Errorf("Error: failed to collect workspaces.\nReason: %s", err)
		}

		if len(workspaces) == 0 {
			return fmt.Errorf("Error: no workspaces found in the tree json.\nHint: make sure to use a file generated by the `swaymsg -t get_tree` output")
		}

		commands, err := parser.SetContainersCommand(workspaces)
		if err != nil {
			return err
		}

		err = swaymsg.Commands(commands)
		if err != nil {
			return err
		}

		return nil

	default:
		errMsg := fmt.Sprintf("Error: type `%s` is not supported\n\n", opts.Type)
		errMsg += fmt.Sprintf("Supported types\n")
		errMsg += fmt.Sprintf(" set_workspaces: set workspaces from `swaymsg -t get_workspaces`\n")
		errMsg += fmt.Sprintf(" set_outputs: set outputs from `swaymsg -t get_outputs`\n")
		errMsg += fmt.Sprintf(" set_containers: set containers from `swaymsg -t get_tree`")
		return fmt.Errorf(errMsg)
	}
}
